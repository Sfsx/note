# gRPC

RPC 远程过程调用，直白的解释就是，将服务调用封装在一个本地的方法中，让调用者调用服务就像调用本地方法一样，对其细节进行屏蔽

广义上讲，所有本地应用程序以外的调用都可以归类为RPC，不管是分布式服务，HTTP接口，redis调用，从抽象角度讲都是RPC，由于不在本地执行，都有一下三个特点：

+ 需要事先约定调用的语义
+ 需要网络传输
+ 需要约定网络传输中的内容格式

## Protobuf

所有的RPC框架就是围绕这几点在不断优化，以更优的方案，达到更低的成不，更快的速度。想要的达到这个目的，**内容编码（Protobuf）** 是非常重要的一点

+ 内容序列化、反序列化，如果效率更高，cpu 消耗会更小
+ 内容在网络中传输，体积越小，效率越高

gRPC 没有使用 json、xml 这种传统的数据交换格式，而是使用 Protocol Buffers 由 Google 开发的一种跨语言、跨平台、可扩展的用于序列化的协议

### 直观对比

对于一段数据，如果使用 json 作为编码方案，常常会得到以下结果

```
"{\"ids\":[123,456],\"info\":{\"is_man\":true,\"age\":20},\"values\":{\"110\":{\"is_man\":false,\"age\":18}}}"
```

所有内容被打包到一个字符串内，体积消耗很大

+ 当 json 体积大，内部可能会有很多重复字段，导致体积消耗
+ 数字用字符串表示，例如 `123` 变成了 `"123"`，由一个字节变成3个字节
+ 类型字符也由字符串表示，如 `[`, `{` 等

如果使用 Protobuf 则会得到二进制串

+ 去掉字段名，转而用字段标号代替
+ 没有类型字符
+ 二进制存储内容，不会将数字转为字符串

这使得 protobuf 的编码体积，通常是 json 的十分之一，同时由于排列简单，其解析算法的时间复杂度远小于 json, 对 cpu 消耗也少

但 protobuf 的缺点在于

+ 无法直接读取二进制数据，需要做反序列化
+ 需要 proto 文件才知道如何解析

**差别在于 json 是对人友好，protobuf 是对机器友好**

## gRPC 与 HTTP2

gRPC 是基于 HTTP2，主要使用 HTTP2 的二进制分帧，既 header 帧与 data 帧

## 参考资料

[什么是RPC](https://zhuanlan.zhihu.com/p/148139089)